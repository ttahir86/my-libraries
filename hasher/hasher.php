<?php


    class Hasher
    {

        public static $_hashScheme = 'sha256';
        public static $_cost;
        private const _GENERATE_RANDOM_SALT = false;
        private const _SALT = "4HqoK8fb79AlKrAoJ8vJLr";
        public static $_options;


        // hash password
        public static function hp($password, $cost=11)
        {
            $param='$'.implode('$',array(
                    "2y", //select the most secure version of blowfish (>=PHP 5.3.7)
                    str_pad($cost,2,"0",STR_PAD_LEFT), //add the cost in two digits
                    self::_getSalt() //add the salt
            ));
           
            //now do the actual hashing
            return crypt($password,$param);
        }

        /*
        * Check the password against a hash generated by the hp
        * function.
        */
        public static function vp($password, $hash)
        {
            /* Regenerating the with an available hash as the options parameter should
                * produce the same hash if the same password is passed.
                */
            return crypt($password, $hash)==$hash;
        }

        private static function _getSalt()
        {
            if(self::_GENERATE_RANDOM_SALT)
            {
                /* To generate the salt, first generate enough random bytes. Because
                * base64 returns one character for each 6 bits, the we should generate
                * at least 22*6/8=16.5 bytes, so we generate 17. Then we get the first
                * 22 base64 characters
                */
                $salt=substr(base64_encode(openssl_random_pseudo_bytes(17)),0,22);
                /* As blowfish takes a salt with the alphabet ./A-Za-z0-9 we have to
                * replace any '+' in the base64 string with '.'. We don't have to do
                * anything about the '=', as this only occurs when the b64 string is
                * padded, which is always after the first 22 characters.
                */
                $salt=str_replace("+",".",$salt);
                /* Next, create a string that will be passed to crypt, containing all
                * of the settings, separated by dollar signs
                */
                return $salt;
                
            }

            return self::_SALT;


        }
        




        // for reference.
        private static  function _printHashingAlgorithims()
        {
            $data = "hello"; 
            
            foreach (hash_algos() as $v) { 
                    $r = hash($v, $data, false); 
                    printf("%-12s %3d %s\n", $v, strlen($r), $r); 
            } 
        }



        private static function _cost()
        {
            /**
             * This code will benchmark your server to determine how high of a cost you can
             * afford. You want to set the highest cost that you can without slowing down
             * you server too much. 8-10 is a good baseline, and more is good if your servers
             * are fast enough. The code below aims for â‰¤ 50 milliseconds stretching time,
             * which is a good baseline for systems handling interactive logins.
             */
            $timeTarget = 0.05; // 50 milliseconds 

            $cost = 8;
            do {
                $cost++;
                $start = microtime(true);
                password_hash("test", PASSWORD_BCRYPT, ["cost" => $cost]);
                $end = microtime(true);
            } while (($end - $start) < $timeTarget);

            $cost;
            return $cost;
        }
    }

?>